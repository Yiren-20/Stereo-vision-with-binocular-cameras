# Stereo-vision-with-binocular-cameras

1. **Image Capture**: Debug the stereo camera to capture the left and right images that meet the requirements.
2. **Stereo Calibration**: Take around 20 images of a chessboard pattern, use corner detection algorithms to calibrate both the left and right cameras, then use monocular calibration matrices for stereo calibration, resulting in the camera's intrinsic and extrinsic parameters.
3. **Stereo Rectification**: After correcting image distortion, apply epipolar geometry constraints to reduce the 2D search for matching points to a 1D search, improving feature matching. This ensures that the imaging origin coordinates of both cameras coincide, the optical axes of the cameras are parallel, the imaging planes are coplanar, and the epipolar lines are aligned.
4. **Disparity Calculation**: The disparity map is obtained through four main steps: matching cost calculation, cost aggregation, disparity calculation, and disparity optimization.
5. **Stereo Depth Map**: The depth information is provided by the disparity map.
6. **Point Cloud Generation**: Calculate the X and Y coordinates of each point in the real world to generate a 3D point cloud. Additionally, texture mapping can be applied through algorithms like triangulation.

# Content
* [Stereo-vision-with-binocular-cameras](#stereo-vision-with-binocular-cameras)
* [Image Capture](#image-capture)
* [Stereo Calibration](#stereo-calibration)
* [Stereo Rectification](#stereo-rectification)
* [Stereo Matching](#stereo-matching)
    * [OpenCV SGBM Algorithm Implementation](#opencv-sgbm-algorithm-implementation)
    * [Semi-Global Matching Algorithm (SGM)](#semi-global-matching-algorithm-sgm)
    * [Depth Map](#depth-map)
* [Point Cloud Generation](#point-cloud-generation)
* [Command line parameters](#command-line-parameters)

# Requirements

This code works well in the following environment:

- Windows 10
- Visual Studio 2022
- OpenCV: 4.5.1
- PCL-1.11.1
- 014 Stereo Datasets

# Image Capture

## Use the chessboard pattern generated by calib.io for calibration.
Chessboard generator website: https://calib.io/pages/camera-calibration-pattern-generator
![image](https://github.com/user-attachments/assets/650e0afb-adab-46c0-8548-d3f6de2e2e66)

## Shooting Process
Using a single USB stereo camera with a maximum resolution of 2560x720, split the captured image at 1280 to obtain the left and right camera images separately.
This step is implemented in `cap.py` (with breakpoint resume functionality, allowing the data capture to continue from the last point each time to prevent image overwriting).

# Stereo Calibration
This step is implemented in `all.py`. It reads the grayscale images captured by the left and right cameras, applies sub-pixel corner refinement for accuracy, and corrects the image distortion.

# Stereo Rectification
This step is implemented in `test.py`.
Histogram equalization is used in preprocessing to handle the captured images, remove lens distortion, and compute the distortion correction and stereo rectification mapping matrices.

# Stereo Matching
Common stereo matching methods can be divided into two categories: local methods (e.g., BM, SGM, ELAS, Patch Match) and non-local (global) methods (e.g., Dynamic Programming, Graph Cut, Belief Propagation).

## OpenCV SGBM Algorithm Implementation
![image](https://github.com/user-attachments/assets/c3806b01-1984-454e-8f9a-e5395dd71445)

## Semi-Global Matching Algorithm (SGM)
The SGM algorithm consists of four parts: initial cost calculation, cost aggregation, disparity calculation, and disparity optimization.
Reference: https://github.com/ethan-li-coding/SemiGlobalMatching
Cost calculation mainly uses Census transform, which compares a pixel with its neighboring pixels and encodes the result as a binary number. To achieve better matching results, SGM uses a global stereo matching algorithm approach, optimizing the energy function. The energy optimization problem remains NP-complete, but SGM efficiently solves it using path-based cost aggregation. In the SGM algorithm, disparity computation uses the Winner-Takes-All (WTA) strategy:
![image](https://github.com/user-attachments/assets/e565d41e-0f95-4005-b513-bd7671557252)

## Depth Map
![image](https://github.com/user-attachments/assets/9c58bd36-bc02-42a7-9b5f-04c72dc46425)

# Point Cloud Generation
For each point in the disparity map, calculate the depth, then use the depth to determine the coordinates in the world coordinate system, resulting in point cloud coordinates.
